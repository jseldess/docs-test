"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[2001],{1869:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>u,frontMatter:()=>t,metadata:()=>o,toc:()=>d});var a=s(5893),r=s(1151);const t={title:"Insert data",category:"6495c32609a24b00434e5b53"},i=void 0,o={id:"data/insert-data",title:"Insert data",description:"After creating a Pinecone index, you can start inserting vector embeddings and metadata into the index.",source:"@site/versioned_docs/version-legacy/data/insert-data.md",sourceDirName:"data",slug:"/data/insert-data",permalink:"/docs/legacy/data/insert-data",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/versioned_docs/version-legacy/data/insert-data.md",tags:[],version:"legacy",frontMatter:{title:"Insert data",category:"6495c32609a24b00434e5b53"},sidebar:"examplesSidebar",previous:{title:"Hybrid search and sparse vectors",permalink:"/docs/legacy/data/hybrid-search-and-sparse-vectors"},next:{title:"Manage data",permalink:"/docs/legacy/data/manage-data"}},c={},d=[{value:"Inserting records",id:"inserting-records",level:2},{value:"Batching upserts",id:"batching-upserts",level:2},{value:"Sending upserts in parallel",id:"sending-upserts-in-parallel",level:2},{value:"Partitioning an index into namespaces",id:"partitioning-an-index-into-namespaces",level:2},{value:"Inserting records with metadata",id:"inserting-records-with-metadata",level:2},{value:"Upserting records with sparse values",id:"upserting-records-with-sparse-values",level:2},{value:"Limitations",id:"limitations",level:3},{value:"Troubleshooting index fullness errors",id:"troubleshooting-index-fullness-errors",level:2}];function l(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:"After creating a Pinecone index, you can start inserting vector embeddings and metadata into the index."}),"\n",(0,a.jsx)("html",{children:(0,a.jsx)("iframe",{width:"450",height:"253",src:"https://www.youtube.com/embed/HjeW6ed2dmI",title:"YouTube video player",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture",allowfullscreen:!0})}),"\n",(0,a.jsx)(n.h2,{id:"inserting-records",children:"Inserting records"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Create a client instance and target an index:"}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'import pinecone\n\npinecone.init(api_key="YOUR_API_KEY", environment="YOUR_ENVIRONMENT")\nindex = pinecone.Index("pinecone-index")\n'})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'import { Pinecone } from \'@pinecone-database/pinecone\'\n\nconst pinecone = new Pinecone({\n  apiKey: "YOUR_API_KEY",\n  environment: "YOUR_ENVIRONMENT"\n})\nconst index = pinecone.index("pinecone-index")\n'})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-shell",metastring:"curl",children:"# Not applicable\n"})}),"\n",(0,a.jsxs)(n.ol,{start:"2",children:["\n",(0,a.jsx)(n.li,{children:"Use the upsert operation to write records into the index:"}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'# Insert sample data (5 8-dimensional vectors)\nindex.upsert([\n    ("A", [0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1]),\n    ("B", [0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2]),\n    ("C", [0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3]),\n    ("D", [0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4]),\n    ("E", [0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5])\n])\n'})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:" const records = [\n    {\n      id: 'A',\n      values: [0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1],\n    },\n    {\n      id: 'B',\n      values: [0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2],\n    },\n    {\n      id: 'C',\n      values: [0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3],\n    },\n    {\n      id: 'D',\n      values: [0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4],\n    },\n    {\n      id: 'E',\n      values: [0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5],\n    }\n]\n\nawait index.upsert(records);\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-shell",metastring:"curl",children:'PINECONE_ENVIRONMENT=\'your-environment\'\nPINECONE_API_KEY=\'your-api-key\'\nINDEX_NAME=\'index-name\'\n\nPINECONE_PROJECT_ID=$(\n  curl "https://controller.$PINECONE_ENVIRONMENT.pinecone.io/actions/whoami" \\\n    -H "Api-Key: $PINECONE_API_KEY" | jq -r \'.project_name\'\n)\n\ncurl -X POST "https://$INDEX_NAME-$PINECONE_PROJECT_ID.svc.$PINECONE_ENVIRONMENT.pinecone.io/vectors/upsert" \\\n  -H "Api-Key: $PINECONE_API_KEY" \\\n  -H \'Content-Type: application/json\' \\\n  -d \'{\n    "vectors": [\n      {\n        "id": "A",\n        "values": [0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1]\n      },\n      {\n        "id": "B",\n        "values": [0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2]\n      },\n      {\n        "id": "C",\n        "values": [0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3]\n      },\n      {\n        "id": "D",\n        "values": [0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4]\n      },\n      {\n        "id": "E",\n        "values": [0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5]\n      }\n    ]\n  }\'\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Immediately after the upsert response is received, records may not be visible to queries yet. This is because Pinecone is eventually consistent. In most situations, you can check if the records have been received by checking for the record counts returned by ",(0,a.jsx)(n.code,{children:"describe_index_stats()"})," to be updated. Keep in mind that if you have multiple replicas, they may not all become consistent at the same time."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"index.describe_index_stats()\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"await index('index-name').describeIndexStats()\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-shell",metastring:"curl",children:"PINECONE_ENVIRONMENT='your-environment'\nPINECONE_API_KEY='your-api-key'\nINDEX_NAME='index-name'\n\nPINECONE_PROJECT_ID=$(\n  curl \"https://controller.$PINECONE_ENVIRONMENT.pinecone.io/actions/whoami\" \\\n    -H \"Api-Key: $PINECONE_API_KEY\" | jq -r '.project_name'\n)\n\ncurl \"https://$INDEX_NAME-$PINECONE_PROJECT_ID.svc.$PINECONE_ENVIRONMENT.pinecone.io/describe_index_stats\" \\\n  -H \"Api-Key: $PINECONE_API_KEY\"\n"})}),"\n",(0,a.jsx)(n.h2,{id:"batching-upserts",children:"Batching upserts"}),"\n",(0,a.jsx)(n.p,{children:"For clients upserting larger amounts of data, you should insert data into an index in batches of 100 vectors or fewer over multiple upsert requests."}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Example"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'import random\nimport itertools\n\ndef chunks(iterable, batch_size=100):\n    """A helper function to break an iterable into chunks of size batch_size."""\n    it = iter(iterable)\n    chunk = tuple(itertools.islice(it, batch_size))\n    while chunk:\n        yield chunk\n        chunk = tuple(itertools.islice(it, batch_size))\n\nvector_dim = 128\nvector_count = 10000\n\n# Example generator that generates many (id, vector) pairs\nexample_data_generator = map(lambda i: (f\'id-{i}\', [random.random() for _ in range(vector_dim)]), range(vector_count))\n\n# Upsert data with 100 vectors per upsert request\nfor ids_vectors_chunk in chunks(example_data_generator, batch_size=100):\n    index.upsert(vectors=ids_vectors_chunk)  # Assuming `index` defined elsewhere\n'})}),"\n",(0,a.jsx)(n.h2,{id:"sending-upserts-in-parallel",children:"Sending upserts in parallel"}),"\n",(0,a.jsxs)(n.p,{children:["By default, all vector operations sent using the Python client block until the response has been received. But using our client they can be made asynchronous. For the ",(0,a.jsx)(n.a,{href:"#batching-upserts",children:"Batching Upserts"})," example this can be done as follows:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"# Upsert data with 100 vectors per upsert request asynchronously\n# - Create pinecone.Index with pool_threads=30 (limits to 30 simultaneous requests)\n# - Pass async_req=True to index.upsert()\nwith pinecone.Index('example-index', pool_threads=30) as index:\n    # Send requests in parallel\n    async_results = [\n        index.upsert(vectors=ids_vectors_chunk, async_req=True)\n        for ids_vectors_chunk in chunks(example_data_generator, batch_size=100)\n    ]\n    # Wait for and retrieve responses (this raises in case of error)\n    [async_result.get() for async_result in async_results]\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-shell",children:"# Not applicable\n"})}),"\n",(0,a.jsx)(n.p,{children:"Pinecone is thread-safe, so you can launch multiple read requests and multiple write requests in parallel. Launching multiple requests can help with improving your throughput. However, reads and writes can\u2019t be performed in parallel, therefore writing in large batches might affect query latency and vice versa."}),"\n",(0,a.jsxs)(n.p,{children:["If you experience slow uploads, see ",(0,a.jsx)(n.a,{href:"performance-tuning",children:"Performance tuning"})," for advice."]}),"\n",(0,a.jsx)(n.h2,{id:"partitioning-an-index-into-namespaces",children:"Partitioning an index into namespaces"}),"\n",(0,a.jsxs)(n.p,{children:['You can organize the records added to an index into partitions, or "namespaces," to limit queries and other vector operations to only one such namespace at a time. For more information, see: ',(0,a.jsx)(n.a,{href:"namespaces",children:"Namespaces"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"inserting-records-with-metadata",children:"Inserting records with metadata"}),"\n",(0,a.jsx)(n.p,{children:"You can insert records that contain metadata as key-value pairs."}),"\n",(0,a.jsxs)(n.p,{children:["You can then use the metadata to filter for those criteria when sending the query. Pinecone will search for similar vector embeddings only among those items that match the filter. For more information, see: ",(0,a.jsx)(n.a,{href:"metadata-filtering",children:"Metadata Filtering"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'index.upsert([\n    ("A", [0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1], {"genre": "comedy", "year": 2020}),\n    ("B", [0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2], {"genre": "documentary", "year": 2019}),\n    ("C", [0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3], {"genre": "comedy", "year": 2019}),\n    ("D", [0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4], {"genre": "drama"}),\n    ("E", [0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5], {"genre": "drama"})\n])\n'})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const records = [\n    {\n      id: 'A',\n      values: [0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1],\n      metadata: { genre: \"comedy\", year: 2020 },\n    },\n    {\n      id: 'B',\n      values: [0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2],\n      metadata: { genre: \"documentary\", year: 2019 },\n    },\n    {\n      id: 'C',\n      values: [0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3],\n      metadata: { genre: \"comedy\", year: 2019 },\n    },\n    {\n      id: 'D',\n      values: [0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4],\n      metadata: { genre: \"drama\" },\n    },\n    {\n      id: 'E',\n      values: [0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5],\n      metadata: { genre: \"drama\" },\n    }\n]\n\nawait index.upsert(records);\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-shell",metastring:"curl",children:'PINECONE_ENVIRONMENT=\'your-environment\'\nPINECONE_API_KEY=\'your-api-key\'\nINDEX_NAME=\'index-name\'\n\nPINECONE_PROJECT_ID=$(\n  curl "https://controller.$PINECONE_ENVIRONMENT.pinecone.io/actions/whoami" \\\n    -H "Api-Key: $PINECONE_API_KEY" | jq -r \'.project_name\'\n)\n\ncurl -X POST "https://$INDEX_NAME-$PINECONE_PROJECT_ID.svc.$PINECONE_ENVIRONMENT.pinecone.io/vectors/upsert" \\\n  -H "Api-Key: $PINECONE_API_KEY" \\\n  -H \'Content-Type: application/json\' \\\n  -d \'{\n    "vectors": [\n      {\n        "id": "A",\n        "values": [0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1],\n        "metadata": {"genre": "comedy", "year": 2020}\n      },\n      {\n        "id": "B",\n        "values": [0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2],\n        "metadata": {"genre": "documentary", "year": 2019}\n      },\n      {\n        "id": "C",\n        "values": [0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3],\n        "metadata": {"genre": "comedy", "year": 2019}\n      },\n      {\n        "id": "D",\n        "values": [0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4],\n        "metadata": {"genre": "drama"}\n      },\n      {\n        "id": "E",\n        "values": [0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5],\n        "metadata": {"genre": "drama"}\n      }\n    ]\n  }\'\n'})}),"\n",(0,a.jsx)(n.h2,{id:"upserting-records-with-sparse-values",children:"Upserting records with sparse values"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.a,{href:"hybrid-search",children:"Sparse vector values"})," can be upserted alongside dense vector values."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"index = pinecone.Index('example-index') \n\nupsert_response = index.upsert(\n  vectors=[\n    {'id': 'vec1',\n      'values': [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8],\n      'metadata': {'genre': 'drama'},\n      'sparse_values': {\n          'indices': [1, 5],\n          'values': [0.5, 0.5]\n      }},\n    {'id': 'vec2',\n      'values': [0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9],\n      'metadata': {'genre': 'action'},\n      'sparse_values': {\n          'indices': [5, 6],\n          'values': [0.4, 0.5]\n      }}\n  ],\n  namespace='example-namespace'\n)\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"index = pinecone.index('example-index')\n\nawait index.upsert([\n    {\n      id: 'vec1',\n      values: [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8],\n      sparseValues: {\n          indices: [1, 5],\n          values: [0.5, 0.5]\n      },\n      metadata: {genre: 'drama'},\n    },\n    {\n      id: 'vec2',\n      values: [0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9],\n      metadata: {'genre': 'action'},\n      sparseValues: {\n          indices: [5, 6],\n          values: [0.4, 0.5]\n      }\n    }\n])\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-shell",metastring:"curl",children:'PINECONE_ENVIRONMENT=\'your-environment\'\nPINECONE_API_KEY=\'your-api-key\'\nINDEX_NAME=\'index-name\'\n\nPINECONE_PROJECT_ID=$(\n  curl "https://controller.$PINECONE_ENVIRONMENT.pinecone.io/actions/whoami" \\\n    -H "Api-Key: $PINECONE_API_KEY" | jq -r \'.project_name\'\n)\n\ncurl -X POST "https://$INDEX_NAME-$PINECONE_PROJECT_ID.svc.$PINECONE_ENVIRONMENT.pinecone.io/vectors/upsert" \\\n  -H "Api-Key: $PINECONE_API_KEY" \\\n  -H "content-type: application/json" \\\n  -d \'{\n        "vectors": [\n          {\n            "values": [\n              0.1,\n              0.2,\n              0.3,\n              0.4,\n              0.5,\n              0.6,\n              0.7,\n              0.8\n            ],\n            "sparseValues": {\n              "indices": [\n                2,\n                7\n              ],\n              "values": [\n                0.4,\n                0.5\n              ]\n            },\n            "id": "vec1"\n          },\n          {\n            "values": [\n              0.2,\n              0.3,\n              0.4,\n              0.5,\n              0.6,\n              0.7,\n              0.8,\n              0.9\n            ],\n            "sparseValues": {\n              "indices": [\n                1,\n                4\n              ],\n              "values": [\n                0.1,\n                0.2\n              ]\n            },\n            "id": "vec2"\n          }\n        ]\n      }\'\n'})}),"\n",(0,a.jsx)(n.h3,{id:"limitations",children:"Limitations"}),"\n",(0,a.jsx)(n.p,{children:"The following limitations apply to upserting records with sparse vectors:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"You cannot upsert a record with sparse vector values without dense vector values."}),"\n",(0,a.jsxs)(n.li,{children:["Only ",(0,a.jsx)(n.code,{children:"s1"})," and ",(0,a.jsx)(n.code,{children:"p1"})," pod types using the ",(0,a.jsx)(n.code,{children:"dotproduct"})," metric support querying sparse vectors. There is no error at upsert time: if you attempt to query any other pod type using sparse vectors, Pinecone returns an error."]}),"\n",(0,a.jsx)(n.li,{children:"You can only upsert sparse vector values of sizes up to 1000 non-zero values."}),"\n",(0,a.jsx)(n.li,{children:"Indexes created before February 22, 2023 do not support sparse values."}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"troubleshooting-index-fullness-errors",children:"Troubleshooting index fullness errors"}),"\n",(0,a.jsx)(n.p,{children:"When upserting data, you may receive the following error:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-console",children:"Index is full, cannot accept data.\n"})}),"\n",(0,a.jsx)(n.p,{children:"New upserts may fail as the capacity becomes exhausted. While your index can still serve queries, you need to scale your environment to accommodate more vectors."}),"\n",(0,a.jsxs)(n.p,{children:["To resolve this issue, you can ",(0,a.jsx)(n.a,{href:"scaling-indexes",children:"scale your index"}),"."]})]})}function u(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},1151:(e,n,s)=>{s.d(n,{Z:()=>o,a:()=>i});var a=s(7294);const r={},t=a.createContext(r);function i(e){const n=a.useContext(t);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),a.createElement(t.Provider,{value:n},e.children)}}}]);